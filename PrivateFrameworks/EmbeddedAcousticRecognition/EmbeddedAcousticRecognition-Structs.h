/*
* This header is generated by classdump-dyld 0.7
* on Sunday, July 5, 2015 at 9:40:28 PM Eastern Daylight Time
* Operating System: Version 8.4 (Build 12H143)
* Image Source: /System/Library/PrivateFrameworks/EmbeddedAcousticRecognition.framework/EmbeddedAcousticRecognition
* classdump-dyld is licensed under GPLv3, Copyright Â© 2013 by Elias Limneos.
*/

typedef struct Vector<float> {
	float data_;
	int dim_;
	int capacity_;
} Vector<float>;

typedef struct opaque_pthread_mutex_t {
	long __sig;
	char __opaque[40];
} opaque_pthread_mutex_t;

typedef struct opaque_pthread_cond_t {
	long __sig;
	char __opaque[24];
} opaque_pthread_cond_t;

typedef struct thread {
	_opaque_pthread_t __t_;
} thread;

typedef struct shared_ptr<std::__1::mutex> {
	mutex __ptr_;
	__shared_weak_count __cntrl_;
} shared_ptr<std::__1::mutex>;

typedef struct condition_variable {
	opaque_pthread_cond_t __cv_;
} condition_variable;

typedef struct condition_variable_any {
	condition_variable __cv_;
	shared_ptr<std::__1::mutex> __mut_;
} condition_variable_any;

typedef struct mutex {
	opaque_pthread_mutex_t __m_;
} mutex;

typedef struct RecogAudioBuffer {
	/*function pointer*/void* _vptr$OnlineAudioSourceItf;
	int state;
	unsigned samplingRate;
	int maxBufferLen;
	BOOL maxBufferLenReached;
	unsigned bufferPos;
	Vector<float> linearBuffer;
	mutex bufferMutex;
	condition_variable_any bufferCond;
	thread recogThread;
	BOOL endOfAudio;
} RecogAudioBuffer;

typedef struct NnetTrainOptions {
	float learn_rate;
	float momentum;
	float l2_penalty;
	float l1_penalty;
} NnetTrainOptions;

typedef struct _compressed_pair<kaldi::CuMatrix<float> *, std::__1::allocator<kaldi::CuMatrix<float> > > {
	CuMatrix<float> __first_;
} compressed_pair<kaldi::CuMatrix<float> *, std::__1::allocator<kaldi::CuMatrix<float> > >;

typedef struct vector<kaldi::CuMatrix<float>, std::__1::allocator<kaldi::CuMatrix<float> > > {
	CuMatrix<float> __begin_;
	CuMatrix<float> __end_;
	compressed_pair<kaldi::CuMatrix<float> *, std::__1::allocator<kaldi::CuMatrix<float> > > __end_cap_;
} vector<kaldi::CuMatrix<float>, std::__1::allocator<kaldi::CuMatrix<float> > >;

typedef struct _compressed_pair<kaldi::nnet1::Component **, std::__1::allocator<kaldi::nnet1::Component *> > {
	Component __first_;
} compressed_pair<kaldi::nnet1::Component **, std::__1::allocator<kaldi::nnet1::Component *> >;

typedef struct vector<kaldi::nnet1::Component *, std::__1::allocator<kaldi::nnet1::Component *> > {
	Component __begin_;
	Component __end_;
	compressed_pair<kaldi::nnet1::Component **, std::__1::allocator<kaldi::nnet1::Component *> > __end_cap_;
} vector<kaldi::nnet1::Component *, std::__1::allocator<kaldi::nnet1::Component *> >;

typedef struct Nnet {
	vector<kaldi::nnet1::Component *, std::__1::allocator<kaldi::nnet1::Component *> > components_;
	vector<kaldi::CuMatrix<float>, std::__1::allocator<kaldi::CuMatrix<float> > > propagate_buf_;
	vector<kaldi::CuMatrix<float>, std::__1::allocator<kaldi::CuMatrix<float> > > backpropagate_buf_;
	NnetTrainOptions opts_;
} Nnet;

